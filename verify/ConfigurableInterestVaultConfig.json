{
    "language": "Solidity",
    "sources": {
      "solidity/contracts/6/protocol/ConfigurableInterestVaultConfig.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.6.6;\r\n\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\r\n\r\nimport \"./interfaces/IVaultConfig.sol\";\r\nimport \"./interfaces/IWorkerConfig.sol\";\r\nimport \"./interfaces/InterestModel.sol\";\r\n\r\ncontract ConfigurableInterestVaultConfig is IVaultConfig, OwnableUpgradeSafe {\r\n  /// @notice Events\r\n  event SetWhitelistedCaller(address indexed caller, address indexed addr, bool ok);\r\n  event SetParams(\r\n    address indexed caller,\r\n    uint256 minDebtSize,\r\n    uint256 reservePoolBps,\r\n    uint256 killBps,\r\n    address interestModel,\r\n    address wrappedNative,\r\n    address wNativeRelayer,\r\n    address fairLaunch,\r\n    uint256 killTreasuryBps,\r\n    address treasury\r\n  );\r\n  event SetWorkers(address indexed caller, address worker, address workerConfig);\r\n  event SetMaxKillBps(address indexed caller, uint256 maxKillBps);\r\n  event SetWhitelistedLiquidator(address indexed caller, address indexed addr, bool ok);\r\n  event SetApprovedAddStrategy(address indexed caller, address addStrat, bool ok);\r\n  event SetNFTStaking(address indexed caller, address nftStaking);\r\n\r\n  /// The minimum debt size per position.\r\n  uint256 public override minDebtSize;\r\n  /// The portion of interests allocated to the reserve pool.\r\n  uint256 public override getReservePoolBps;\r\n  /// The reward for successfully killing a position.\r\n  uint256 public override getKillBps;\r\n  /// Mapping for worker address to its configuration.\r\n  mapping(address => IWorkerConfig) public workers;\r\n  /// Interest rate model\r\n  InterestModel public interestModel;\r\n  /// address for wrapped native eg WBNB, WETH\r\n  address public override getWrappedNativeAddr;\r\n  /// address for wNtive Relayer\r\n  address public override getWNativeRelayer;\r\n  /// address of fairLaunch contract\r\n  address public override getFairLaunchAddr;\r\n  /// maximum killBps\r\n  uint256 public maxKillBps;\r\n  /// list of whitelisted callers\r\n  mapping(address => bool) public override whitelistedCallers;\r\n  // The portion of reward that will be transferred to treasury account after successfully killing a position.\r\n  uint256 public override getKillTreasuryBps;\r\n  // address of treasury account\r\n  address public treasury;\r\n  // Mapping of approved add strategies\r\n  mapping(address => bool) public override approvedAddStrategies;\r\n  // list of whitelisted liquidators\r\n  mapping(address => bool) public override whitelistedLiquidators;\r\n  address public nftStaking;\r\n\r\n  function initialize(\r\n    uint256 _minDebtSize,\r\n    uint256 _reservePoolBps,\r\n    uint256 _killBps,\r\n    InterestModel _interestModel,\r\n    address _getWrappedNativeAddr,\r\n    address _getWNativeRelayer,\r\n    address _getFairLaunchAddr,\r\n    uint256 _getKillTreasuryBps,\r\n    address _treasury\r\n  ) external initializer {\r\n    OwnableUpgradeSafe.__Ownable_init();\r\n\r\n    maxKillBps = 500;\r\n    setParams(\r\n      _minDebtSize,\r\n      _reservePoolBps,\r\n      _killBps,\r\n      _interestModel,\r\n      _getWrappedNativeAddr,\r\n      _getWNativeRelayer,\r\n      _getFairLaunchAddr,\r\n      _getKillTreasuryBps,\r\n      _treasury\r\n    );\r\n  }\r\n\r\n  /// @dev Set all the basic parameters. Must only be called by the owner.\r\n  /// @param _minDebtSize The new minimum debt size value.\r\n  /// @param _reservePoolBps The new interests allocated to the reserve pool value.\r\n  /// @param _killBps The new reward for killing a position value.\r\n  /// @param _interestModel The new interest rate model contract.\r\n  /// @param _getKillTreasuryBps The portion of reward that will be transferred to treasury account after successfully killing a position.\r\n  /// @param _treasury address of treasury account\r\n  function setParams(\r\n    uint256 _minDebtSize,\r\n    uint256 _reservePoolBps,\r\n    uint256 _killBps,\r\n    InterestModel _interestModel,\r\n    address _getWrappedNativeAddr,\r\n    address _getWNativeRelayer,\r\n    address _getFairLaunchAddr,\r\n    uint256 _getKillTreasuryBps,\r\n    address _treasury\r\n  ) public onlyOwner {\r\n    require(\r\n      _killBps + _getKillTreasuryBps <= maxKillBps,\r\n      \"ConfigurableInterestVaultConfig::setParams:: kill bps exceeded max kill bps\"\r\n    );\r\n\r\n    minDebtSize = _minDebtSize;\r\n    getReservePoolBps = _reservePoolBps;\r\n    getKillBps = _killBps;\r\n    interestModel = _interestModel;\r\n    getWrappedNativeAddr = _getWrappedNativeAddr;\r\n    getWNativeRelayer = _getWNativeRelayer;\r\n    getFairLaunchAddr = _getFairLaunchAddr;\r\n    getKillTreasuryBps = _getKillTreasuryBps;\r\n    treasury = _treasury;\r\n\r\n    emit SetParams(\r\n      _msgSender(),\r\n      minDebtSize,\r\n      getReservePoolBps,\r\n      getKillBps,\r\n      address(interestModel),\r\n      getWrappedNativeAddr,\r\n      getWNativeRelayer,\r\n      getFairLaunchAddr,\r\n      getKillTreasuryBps,\r\n      treasury\r\n    );\r\n  }\r\n\r\n  /// @dev Set the configuration for the given workers. Must only be called by the owner.\r\n  function setWorkers(address[] calldata addrs, IWorkerConfig[] calldata configs) external onlyOwner {\r\n    require(addrs.length == configs.length, \"ConfigurableInterestVaultConfig::setWorkers:: bad length\");\r\n    for (uint256 idx = 0; idx < addrs.length; idx++) {\r\n      workers[addrs[idx]] = configs[idx];\r\n      emit SetWorkers(_msgSender(), addrs[idx], address(configs[idx]));\r\n    }\r\n  }\r\n\r\n  /// @dev Set whitelisted callers. Must only be called by the owner.\r\n  function setWhitelistedCallers(address[] calldata callers, bool ok) external onlyOwner {\r\n    for (uint256 idx = 0; idx < callers.length; idx++) {\r\n      whitelistedCallers[callers[idx]] = ok;\r\n      emit SetWhitelistedCaller(_msgSender(), callers[idx], ok);\r\n    }\r\n  }\r\n\r\n  /// @dev Set approved add strategies. Must only be called by the owner.\r\n  function setApprovedAddStrategy(address[] calldata addStrats, bool ok) external onlyOwner {\r\n    for (uint256 idx = 0; idx < addStrats.length; idx++) {\r\n      approvedAddStrategies[addStrats[idx]] = ok;\r\n      emit SetApprovedAddStrategy(_msgSender(), addStrats[idx], ok);\r\n    }\r\n  }\r\n\r\n  /// @dev Set max kill bps. Must only be called by the owner.\r\n  function setMaxKillBps(uint256 _maxKillBps) external onlyOwner {\r\n    require(_maxKillBps < 1000, \"ConfigurableInterestVaultConfig::setMaxKillBps:: bad _maxKillBps\");\r\n    maxKillBps = _maxKillBps;\r\n    emit SetMaxKillBps(_msgSender(), maxKillBps);\r\n  }\r\n\r\n  /// @dev Set whitelisted liquidators. Must only be called by the owner.\r\n  function setWhitelistedLiquidators(address[] calldata callers, bool ok) external onlyOwner {\r\n    for (uint256 idx = 0; idx < callers.length; idx++) {\r\n      whitelistedLiquidators[callers[idx]] = ok;\r\n      emit SetWhitelistedLiquidator(_msgSender(), callers[idx], ok);\r\n    }\r\n  }\r\n\r\n  function setNftStaking(address newNftStaking) external onlyOwner {\r\n    nftStaking = newNftStaking;\r\n\r\n    emit SetNFTStaking(_msgSender(), newNftStaking);\r\n  }\r\n\r\n  /// @dev Return the interest rate per second, using 1e18 as denom.\r\n  function getInterestRate(uint256 debt, uint256 floating) external view override returns (uint256) {\r\n    return interestModel.getInterestRate(debt, floating);\r\n  }\r\n\r\n  /// @dev Return whether the given address is a worker.\r\n  function isWorker(address worker) external view override returns (bool) {\r\n    return address(workers[worker]) != address(0);\r\n  }\r\n\r\n  /// @dev Return whether the given worker accepts more debt. Revert on non-worker.\r\n  function acceptDebt(address worker) external view override returns (bool) {\r\n    return workers[worker].acceptDebt(worker);\r\n  }\r\n\r\n  /// @dev Return the work factor for the worker + debt, using 1e4 as denom. Revert on non-worker.\r\n  function workFactor(address worker, uint256 debt) external view override returns (uint256) {\r\n    return workers[worker].workFactor(worker, debt);\r\n  }\r\n\r\n  /// @dev Return the work factor for the worker + debt, using 1e4 as denom. Revert on non-worker.\r\n  /// Also check for boosted leverage from NFT staking\r\n  function workFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view override returns (uint256) {\r\n    if (nftStaking != address(0)) {\r\n      return workers[worker].workFactor(worker, debt, positionOwner);\r\n    }\r\n    return workers[worker].workFactor(worker, debt);\r\n  }\r\n\r\n  /// @dev Return the kill factor for the worker + debt, using 1e4 as denom. Revert on non-worker.\r\n  function killFactor(address worker, uint256 debt) external view override returns (uint256) {\r\n    return workers[worker].killFactor(worker, debt);\r\n  }\r\n\r\n  function killFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view override returns (uint256) {\r\n    if (nftStaking != address(0)) {\r\n      return workers[worker].killFactor(worker, debt, positionOwner);\r\n    }\r\n    return workers[worker].killFactor(worker, debt);\r\n  }\r\n\r\n  /// @dev Return the kill factor for the worker + BaseToken debt, using 1e4 as denom.\r\n  function rawKillFactor(address worker, uint256 debt) external view override returns (uint256) {\r\n    return workers[worker].rawKillFactor(worker, debt);\r\n  }\r\n\r\n  function rawKillFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view override returns (uint256) {\r\n    if (nftStaking != address(0)) {\r\n      return workers[worker].rawKillFactor(worker, debt, positionOwner);\r\n    }\r\n    return workers[worker].rawKillFactor(worker, debt);\r\n  }\r\n\r\n  /// @dev Return if worker is stable.\r\n  function isWorkerStable(address worker) external view override returns (bool) {\r\n    return workers[worker].isStable(worker);\r\n  }\r\n\r\n  /// @dev Return if pools is consistent\r\n  function isWorkerReserveConsistent(address worker) external view override returns (bool) {\r\n    return workers[worker].isReserveConsistent(worker);\r\n  }\r\n\r\n  /// @dev Return the treasuryAddr\r\n  function getTreasuryAddr() external view override returns (address) {\r\n    return treasury == address(0) ? 0xC44f82b07Ab3E691F826951a6E335E1bC1bB0B51 : treasury;\r\n  }\r\n}\r\n"
      },
      "@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol": {
        "content": "pragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n\n\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n\n    }\n\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[49] private __gap;\n}\n"
      },
      "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
        "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
      },
      "@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol": {
        "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
      },
      "solidity/contracts/6/protocol/interfaces/IVaultConfig.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IVaultConfig {\r\n  /// @dev Return minimum BaseToken debt size per position.\r\n  function minDebtSize() external view returns (uint256);\r\n\r\n  /// @dev Return the interest rate per second, using 1e18 as denom.\r\n  function getInterestRate(uint256 debt, uint256 floating) external view returns (uint256);\r\n\r\n  /// @dev Return the address of wrapped native token.\r\n  function getWrappedNativeAddr() external view returns (address);\r\n\r\n  /// @dev Return the address of wNative relayer.\r\n  function getWNativeRelayer() external view returns (address);\r\n\r\n  /// @dev Return the address of fair launch contract.\r\n  function getFairLaunchAddr() external view returns (address);\r\n\r\n  /// @dev Return the bps rate for reserve pool.\r\n  function getReservePoolBps() external view returns (uint256);\r\n\r\n  /// @dev Return the bps rate for Avada Kill caster.\r\n  function getKillBps() external view returns (uint256);\r\n\r\n  /// @dev Return if the caller is whitelisted.\r\n  function whitelistedCallers(address caller) external returns (bool);\r\n\r\n  /// @dev Return if the caller is whitelisted.\r\n  function whitelistedLiquidators(address caller) external returns (bool);\r\n\r\n  /// @dev Return if the given strategy is approved.\r\n  function approvedAddStrategies(address addStrats) external returns (bool);\r\n\r\n  /// @dev Return whether the given address is a worker.\r\n  function isWorker(address worker) external view returns (bool);\r\n\r\n  /// @dev Return whether the given worker accepts more debt. Revert on non-worker.\r\n  function acceptDebt(address worker) external view returns (bool);\r\n\r\n  /// @dev Return the work factor for the worker + BaseToken debt, using 1e4 as denom. Revert on non-worker.\r\n  function workFactor(address worker, uint256 debt) external view returns (uint256);\r\n\r\n  /// @dev Return the work factor for the worker + debt, using 1e4 as denom. Revert on non-worker.\r\n  /// Also check for boosted leverage from NFT staking\r\n  function workFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + BaseToken debt, using 1e4 as denom. Revert on non-worker.\r\n  function killFactor(address worker, uint256 debt) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + BaseToken debt, using 1e4 as denom. Revert on non-worker.\r\n  /// Also check for boosted kill factor from NFT staking\r\n  function killFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + BaseToken debt without checking isStable, using 1e4 as denom. Revert on non-worker.\r\n  function rawKillFactor(address worker, uint256 debt) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + BaseToken debt without checking isStable, using 1e4 as denom. Revert on non-worker.\r\n  /// Also check for boosted kill factor from NFT staking\r\n  function rawKillFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view returns (uint256);\r\n\r\n  /// @dev Return the portion of reward that will be transferred to treasury account after successfully killing a position.\r\n  function getKillTreasuryBps() external view returns (uint256);\r\n\r\n  /// @dev Return the address of treasury account\r\n  function getTreasuryAddr() external view returns (address);\r\n\r\n  /// @dev Return if worker is stable\r\n  function isWorkerStable(address worker) external view returns (bool);\r\n\r\n  /// @dev Return if reserve that worker is working with is consistent\r\n  function isWorkerReserveConsistent(address worker) external view returns (bool);\r\n}\r\n"
      },
      "solidity/contracts/6/protocol/interfaces/IWorkerConfig.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface IWorkerConfig {\r\n  /// @dev Return whether the given worker accepts more debt.\r\n  function acceptDebt(address worker) external view returns (bool);\r\n\r\n  /// @dev Return the work factor for the worker + debt, using 1e4 as denom.\r\n  function workFactor(address worker, uint256 debt) external view returns (uint256);\r\n\r\n  /// @dev Return the work factor for the worker + debt, using 1e4 as denom.\r\n  function workFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + debt, using 1e4 as denom.\r\n  function killFactor(address worker, uint256 debt) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + debt, using 1e4 as denom.\r\n  function killFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + debt without checking isStable, using 1e4 as denom.\r\n  function rawKillFactor(address worker, uint256 debt) external view returns (uint256);\r\n\r\n  /// @dev Return the kill factor for the worker + debt without checking isStable, using 1e4 as denom.\r\n  function rawKillFactor(\r\n    address worker,\r\n    uint256 debt,\r\n    address positionOwner\r\n  ) external view returns (uint256);\r\n\r\n  /// @dev Return if worker is stable.\r\n  function isStable(address worker) external view returns (bool);\r\n\r\n  /// @dev Revert if liquidity pool under manipulation\r\n  function isReserveConsistent(address worker) external view returns (bool);\r\n}\r\n"
      },
      "solidity/contracts/6/protocol/interfaces/InterestModel.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface InterestModel {\r\n  /// @dev Return the interest rate per second, using 1e18 as denom.\r\n  function getInterestRate(uint256 debt, uint256 floating) external view returns (uint256);\r\n}"
      },
      "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
        "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 1
      },
      "evmVersion": "istanbul",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "evm.bytecode.object",
            "evm.deployedBytecode.object",
            "abi",
            "evm.bytecode.sourceMap",
            "evm.deployedBytecode.sourceMap",
            "metadata",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "devdoc",
            "userdoc",
            "storageLayout",
            "evm.gasEstimates"
          ]
        }
      },
      "metadata": {
        "useLiteralContent": true
      }
    }
}

